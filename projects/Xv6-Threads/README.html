<h1 id="kernel-threads">Kernel Threads</h1>
<p>In this project, you'll be adding real kernel threads to xv6. Sound like fun? Well, it should. Because you are on your way to becoming a real kernel hacker. And what could be more fun than that?</p>
<p>Specifically, you'll do three things. First, you'll define a new system call to create a kernel thread, called <code>clone()</code>, as well as one to wait for a thread called <code>join()</code>. Then, you'll use <code>clone()</code> to build a little thread library, with a <code>thread_create()</code> call and <code>lock_acquire()</code> and <code>lock_release()</code> functions. That's it! And now, for some details.</p>
<h2 id="overview">Overview</h2>
<p>Your new clone system call should look like this: <code>int clone(void(*fcn)(void *, void *), void *arg1, void *arg2, void *stack)</code>. This call creates a new kernel thread which shares the calling process's address space. File descriptors are copied as in <code>fork()</code>. The new process uses <code>stack</code> as its user stack, which is passed two arguments (<code>arg1</code> and <code>arg2</code>) and uses a fake return PC (<code>0xffffffff</code>); a proper thread will simply call <code>exit()</code> when it is done (and not <code>return</code>). The stack should be one page in size and page-aligned. The new thread starts executing at the address specified by <code>fcn</code>. As with <code>fork()</code>, the PID of the new thread is returned to the parent (for simplicity, threads each have their own process ID).</p>
<p>The other new system call is <code>int join(void **stack)</code>. This call waits for a child thread that shares the address space with the calling process to exit. It returns the PID of waited-for child or -1 if none. The location of the child's user stack is copied into the argument <code>stack</code> (which can then be freed).</p>
<p>You also need to think about the semantics of a couple of existing system calls. For example, <code>int wait()</code> should wait for a child process that does not share the address space with this process. It should also free the address space if this is last reference to it. Also, <code>exit()</code> should work as before but for both processes and threads; little change is required here.</p>
<p>Your thread library will be built on top of this, and just have a simple <code>int thread_create(void (*start_routine)(void *, void *), void *arg1, void *arg2)</code> routine. This routine should call <code>malloc()</code> to create a new user stack, use <code>clone()</code> to create the child thread and get it running. It returns the newly created PID to the parent and 0 to the child (if successful), -1 otherwise. An <code>int thread_join()</code> call should also be created, which calls the underlying <code>join()</code> system call, frees the user stack, and then returns. It returns the waited-for PID (when successful), -1 otherwise.</p>
<p>Your thread library should also have a simple <em>ticket lock</em> (read <a href="http://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf">this book chapter</a> for more information on this). There should be a type <code>lock_t</code> that one uses to declare a lock, and two routines <code>void lock_acquire(lock_t *)</code> and <code>void lock_release(lock_t *)</code>, which acquire and release the lock. The spin lock should use x86 atomic add to build the lock -- see <a href="https://en.wikipedia.org/wiki/Fetch-and-add">this wikipedia page</a> for a way to create an atomic fetch-and-add routine using the x86 <code>xaddl</code> instruction. One last routine, <code>void lock_init(lock_t *)</code>, is used to initialize the lock as need be (it should only be called by one thread).</p>
<p>The thread library should be available as part of every program that runs in xv6. Thus, you should add prototypes to <code>user/user.h</code> and the actual code to implement the library routines in <code>user/ulib.c</code>.</p>
<p>One thing you need to be careful with is when an address space is grown by a thread in a multi-threaded process (for example, when <code>malloc()</code> is called, it may call <code>sbrk</code> to grow the address space of the process). Trace this code path carefully and see where a new lock is needed and what else needs to be updated to grow an address space in a multi-threaded process correctly.</p>
<h2 id="building-clone-from-fork">Building <code>clone()</code> from <code>fork()</code></h2>
<p>To implement <code>clone()</code>, you should study (and mostly copy) the <code>fork()</code> system call. The <code>fork()</code> system call will serve as a template for <code>clone()</code>, with some modifications. For example, in <code>kernel/proc.c</code>, we see the beginning of the <code>fork()</code> implementation:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span>
fork(<span class="dt">void</span>)
{
  <span class="dt">int</span> i, pid;
  <span class="kw">struct</span> proc *np;

  <span class="co">// Allocate process.</span>
  <span class="kw">if</span>((np = allocproc()) == <span class="dv">0</span>)
    <span class="kw">return</span> -<span class="dv">1</span>;

  <span class="co">// Copy process state from p.</span>
  <span class="kw">if</span>((np-&gt;pgdir = copyuvm(proc-&gt;pgdir, proc-&gt;sz)) == <span class="dv">0</span>){
    kfree(np-&gt;kstack);
    np-&gt;kstack = <span class="dv">0</span>;
    np-&gt;state = UNUSED;
    <span class="kw">return</span> -<span class="dv">1</span>;
  }
  np-&gt;sz = proc-&gt;sz;
  np-&gt;parent = proc;
  *np-&gt;tf = *proc-&gt;tf;</code></pre>
<p>This code does some work you need to have done for <code>clone()</code>, for example, calling <code>allocproc()</code> to allocate a slot in the process table, creating a kernel stack for the new thread, etc.</p>
<p>However, as you can see, the next thing <code>fork()</code> does is copy the address space and point the page directory (<code>np-&gt;pgdir</code>) to a new page table for that address space. When creating a thread (as <code>clone()</code> does), you'll want the new child thread to be in the <em>same</em> address space as the parent; thus, there is no need to create a copy of the address space, and the new thread's <code>np-&gt;pgdir</code> should be the same as the parent's -- they now share the address space, and thus have the same page table.</p>
<p>Once that part is complete, there is a little more effort you'll have to apply inside <code>clone()</code> to make it work. Specifically, you'll have to set up the kernel stack so that when <code>clone()</code> returns in the child (i.e., in the newly created thread), it runs on the user stack passed into clone (<code>stack</code>), that the function <code>fcn</code> is the starting point of the child thread, and that the arguments <code>arg1</code> and <code>arg2</code> are available to that function. This will be a little work on your part to figure out; have fun!</p>
<h2 id="x86-calling-convention">x86 Calling Convention</h2>
<p>One other thing you'll have to understand to make this all work is the x86 calling convention, and exactly how the stack works when calling a function. This is you can read about in <a href="https://download-mirror.savannah.gnu.org/releases/pgubook/ProgrammingGroundUp-1-0-booksize.pdf">Programming From The Ground Up</a>, a free online book. Specifically, you should understand Chapter 4 (and maybe Chapter 3) and the details of call/return. All of this will be useful in getting <code>clone()</code> above to set things up properly on the user stack of the child thread.</p>
